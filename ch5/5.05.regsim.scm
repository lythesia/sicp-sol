(load "util.scm") ; for tagged-list?

;; machine
(define (make-machine register-names ops controller-text) ; text = code
  (let ((machine (make-new-machine)))
    (for-each
      (lambda (register-name) ((machine 'allocate-register) register-name))
      register-names
    )
    ((machine 'install-operations) ops)
    ((machine 'install-instruction-sequence) (assemble controller-text machine))
    machine
  )
)
(define (make-new-machine)
  (let 
    ((pc (make-register 'pc))
     (flag (make-register 'flag))
     (stack (make-stack))
     (the-instruction-sequence '())
    )
    (let
      ((the-ops (list (list 'initialize-stack (lambda () (stack 'initialize)))
                      (list 'print-stack-statistics (lambda () (stack 'print-statistics)))))
       (register-table (list (list 'pc pc) (list 'flag flag)))
      )
      (define (allocate-register name)
        (if (assoc name register-table)
          (error "register redefined:" name)
          (set! register-table (cons (list name (make-register name)) register-table))
        )
      )
      (define (lookup-register name)
        (let ((val (assoc name register-table))) ; entry
          (if val
            (cadr val) ; register object
            (error "Unknown register:" name)
          )
        )
      )
      (define (execute)
        (let ((insts (get-contents pc)))
          (if (null? insts) ; why null?
            'done
            (begin
              ((instruction-execution-proc (car insts))) ; will consume car
              (execute)
            )
          )
        )
      )
      (define (dispatch message)
        (cond
          ((eq? message 'start) (set-contents! pc the-instruction-sequence) (execute))
          ((eq? message 'install-instruction-sequence) (lambda (seq) (set! the-instruction-sequence seq)))
          ((eq? message 'allocate-register) allocate-register)
          ((eq? message 'get-register) lookup-register)
          ((eq? message 'install-operations) (lambda (ops) (set! the-ops (append the-ops ops))))
          ((eq? message 'stack) stack)
          ((eq? message 'operations) the-ops)
          (else (error "Unknown request -- MACHINE" message))
        )
      )
      dispatch
    )
  )
)
(define (start machine)
  (machine 'start)
)
(define (get-register machine register-name)
  ((machine 'get-register) register-name)
)
(define (get-register-contents machine register-name)
  (get-contents (get-register machine register-name))
)
(define (set-register-contents! machine register-name value)
  (set-contents! (get-register machine register-name) value)
)

;; register (why need `name' ?)
(define (make-register name)
  (let ((contents '*unassigned*))
    (define (dispatch message)
      (cond
        ((eq? message 'get) contents)
        ((eq? message 'set) (lambda (value) (set! contents value)))
        (else (error "Unknown request -- REGISTER" message))
      )
    )
    dispatch
  )
)
(define (get-contents register) (register 'get))
(define (set-contents! register value) ((register 'set) value))

;; stack
(define (make-stack)
  (let ((s '())
        (number-pushes 0)
        (max-depth 0)
        (current-depth 0))
    ; push
    (define (push x)
      (set! s (cons x s))
      (set! number-pushes (+ number-pushes 1))
      (set! current-depth (+ current-depth 1))
      (set! max-depth (max max-depth current-depth))
    )
    ; pop
    (define (pop)
      (if (null? s)
        (error "Empty stack -- POP")
        (let ((top (car s)))
          (set! s (cdr s))
          (set! current-depth (- current-depth 1))
          top
        )
      )
    )
    ; init
    (define (initialize)
      (set! s '())
      (set! number-pushes 0)
      (set! max-depth 0)
      (set! current-depth 0)
      'done
    )
    ; profile
    (define (profile)
      (display "\ntotal-pushes: ")(display number-pushes)
      (display ", maximum-depth: ")(display max-depth)
      (newline)
    )
    (define (dispatch message)
      (cond
        ((eq? message 'push) push)
        ((eq? message 'pop) (pop))
        ((eq? message 'initialize) (initialize))
        ((eq? message 'print-statistics) (profile))
        (else (error "Unknown request -- STAKC" message))
      )
    )
    dispatch
  )
)
(define (push stack x)
  ((stack 'push) x)
)
(define (pop stack)
  (stack 'pop)
)

;; assemble
(define (assemble controller-text machine)
  (extract-labels controller-text (lambda (insts labels) (update-insts! insts labels machine) insts))
)

; it's U-like invoke, awesome!
(define (extract-labels text receive)
  (if (null? text)
    (receive '() '())
    (extract-labels
      (cdr text)
      (lambda (insts labels)
        (let ((next-inst (car text)))
          (if (symbol? next-inst)
            ; because we cons at head, so insts&labels order is guaranteed
            (receive insts (cons (make-label-entry next-inst insts) labels))
            (receive (cons (make-instruction next-inst) insts) labels)
          )
        )
      )
    )
  )
)
; inst: (code-text . exec-proc)
(define (make-instruction text) (cons text '()))
(define (instruction-text inst) (car inst))
(define (instruction-execution-proc inst) (cdr inst))
(define (set-instruction-execution-proc! inst proc) (set-cdr! inst proc))
; label: (label-text . all-code-text after label)
(define (make-label-entry label-name insts) (cons label-name insts))
(define (lookup-label labels label-name)
  (let ((val (assoc label-name labels)))
    (if val
      (cdr val) ; code-text?
      (error "Undefined label -- ASSEMBLE" label-name)
    )
  )
)

(define (update-insts! insts labels machine)
  (let
    ((pc (get-register machine 'pc))
     (flag (get-register machine 'flag))
     (stack (machine 'stack))
     (ops (machine 'operations)))
    (for-each
      (lambda (inst)
        (set-instruction-execution-proc!
          inst
          (make-execution-procedure
            (instruction-text inst)
            labels machine pc flag stack ops))
      )
      insts
    )
  )
)

(define (make-execution-procedure inst labels machine pc flag stack ops)
  (let ((op (car inst)))
    (cond
      ((eq? op 'assign) (make-assign inst machine labels ops pc))   ; need `op` to compute
      ((eq? op 'test) (make-test inst machine labels ops flag pc))  ; need `op` to set `flag`
      ((eq? op 'branch) (make-branch inst machine labels flag pc))  ; need check `flag`
      ((eq? op 'goto) (make-goto inst machine labels pc))
      ((eq? op 'save) (make-save inst machine stack pc))
      ((eq? op 'restore) (make-restore inst machine stack pc))
      ((eq? op 'perform) (make-perform inst machine labels ops pc))
      (else (error "Unknown instruction type -- ASSEMBLE" op))
    )
  )
)
; (assign <target> proc...)
(define (make-assign inst machine labels ops pc)
  (let ((target (get-register machine (assign-reg-name inst))) (value-exp (assign-value-proc inst)))
    (let
      ((value-proc
         (if (operation-exp? value-exp)
           (make-operation-exp value-exp machine labels ops)
           (make-primitive-exp (car value-exp) machine labels)
         )
       ))
      (lambda ()
        (set-contents! target (value-proc))
        (advance-pc pc)
      )
    )
  )
)
(define assign-reg-name cadr)
(define assign-value-proc cddr)
; (const ..)
; (label ..)
; (reg ..)
(define (make-primitive-exp exp machine labels)
  (cond
    ((constant-exp? exp)
     (let ((c (constant-exp-value exp))) (lambda () c)))
    ((label-exp? exp)
     (let ((insts (lookup-label labels (label-exp-label exp)))) (lambda () insts)))
    ((register-exp? exp)
     (let ((r (get-register machine (register-exp-reg exp)))) (lambda () (get-contents r))))
    (else (error "Unknown expression type -- ASSEMBLE" exp))
  )
)
(define (constant-exp? exp) (tagged-list? exp 'const))
(define constant-exp-value cadr)
(define (label-exp? exp) (tagged-list? exp 'label))
(define label-exp-label cadr)
(define (register-exp? exp) (tagged-list? exp 'reg))
(define register-exp-reg cadr)
; (op ..) [operands]
; (define (make-operation-exp exp machine lables operations)
;   (let
;     ((op (lookup-operation (operation-exp-op exp) operations))
;      (a-procs (map (lambda (e) (make-primitive-exp e machine labels)) (operation-exp-operands exp))))
;     (lambda () (apply op (map (lambda (p) (p)) a-procs)))
;   )
; )
;; 5.09.scm
(define (make-operation-exp exp machine labels operations)
  (let
    ((op (lookup-operation (operation-exp-op exp) operations))
     (a-procs
       (map
         (lambda (e) (make-primitive-exp e machine labels))
         (operation-exp-operands exp)
       )
     ))
    (lambda () (apply op (map (lambda (p) (p)) a-procs)))
  )
)
(define (operation-exp? exp) (and (pair? exp) (tagged-list? (car exp) 'op)))
(define operation-exp-op cadar)
(define operation-exp-operands cdr)
; (list 'op operation)
(define (lookup-operation symbol operations)
  (let ((val (assoc symbol operations)))
    (if val
      (cadr val)
      (error "Unknown operation -- ASSEMBLE" symbol)
    )
  )
)
(define (advance-pc pc)
  (set-contents! pc (cdr (get-contents pc)))
)

; (test (op ..) [operands])
(define (make-test inst machine labels operations flag pc)
  (let ((condition (test-condition inst)))
    (if (operation-exp? condition)
      (let ((condition-proc (make-operation-exp condition machine labels operations)))
        (lambda () (set-contents! flag (condition-proc)) (advance-pc pc))
      )
      (error "Bad TEST instruction -- ASSEMBLE" inst) ; must be (op ..) [operands]
    )
  )
)
(define test-condition cdr)

; (branch (label ..))
(define (make-branch inst machine labels flag pc)
  (let ((dest (branch-dest inst)))
    (if (label-exp? dest)
      (let ((insts (lookup-label labels (label-exp-label dest)))) ; 1. why lookup-label gives all insts(behind) here?
        (lambda ()
          (if (get-contents flag)
            (set-contents! pc insts)  ; 2. since here we use it to set pc
            (advance-pc pc)
          )
        )
      )
      (error "Bad BRANCH instruction -- ASSEMBLE" inst)
    )
  )
)
(define branch-dest cadr)

; (goto (label/reg ..))
(define (make-goto inst machine labels pc)
  (let ((dest (goto-dest inst)))
    (cond
      ((label-exp? dest)
       (let ((insts (lookup-label labels (label-exp-label dest))))
         (lambda () (set-contents! pc insts))
       ))
      ((register-exp? dest)
       (let ((reg (get-register machine (register-exp-reg dest))))
         (lambda () (set-contents! pc (get-contents reg)))
       ))
      (error "Bad GOTO instruction -- ASSEMBLE" inst)
    )
  )
)
(define goto-dest cadr)

; (save ..)
(define (make-save inst machine stack pc)
  (let ((reg (get-register machine (stack-inst-reg-name inst))))
    (lambda ()
      (push stack (get-contents reg))
      (advance-pc pc)
    )
  )
)
; (restore ..)
(define (make-restore inst machine stack pc)
  (let ((reg (get-register machine (stack-inst-reg-name inst))))
    (lambda ()
      (set-contents! reg (pop stack))
      (advance-pc pc)
    )
  )
)
(define stack-inst-reg-name cadr)

; (perform (op ..) [operands])
(define (make-perform inst machine labels ops pc)
  (let ((action (perform-action inst)))
    (if (operation-exp? action)
      (let ((action-proc (make-operation-exp action machine labels ops)))
        (lambda () (action-proc) (advance-pc pc))
      )
      (error "Bad PERFORM instruction -- ASSEMBLE" inst)
    )
  )
)
(define perform-action cdr)
